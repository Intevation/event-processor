#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Command line tool to send notfications for intelmq events.


Copyright (C) 2016 by Bundesamt f√ºr Sicherheit in der Informationstechnik
Software engineering by Intevation GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

Authors:
    Bernhard Herzog <bernhard.herzog@intevation.de>
    Roland Geider <roland.geider@intevation.de>
    Bernhard E. Reiter <bernhard@intevation.de>

    and others.

Based upon intelmqcli
https://github.com/certat/intelmq/blob/master/intelmq/bin/intelmqcli.py


Requires Python 3.2 because of DictWriter.writeheader()

"""

import smtplib
import argparse
import json
import locale
import logging
import os
import sys
import io
import csv
import string
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

import psycopg2
from psycopg2.extras import RealDictConnection

#local application/library specific imports (we depend on our special pyxarf)
from pyxarf import Xarf
from xarfmail import XarfMail

logging.basicConfig(format='%(asctime)s %(name)s %(levelname)s - %(message)s')
logger = logging.getLogger('intelmq-mailgen')
#logger.setLevel(logging.DEBUG)  # defaults to WARNING

if locale.getpreferredencoding() == 'UTF-8':
    logger.critical(
        'The preferred encoding of your locale setting is not UTF-8'
        ' but "{}". Exiting.'.format(locale.getpreferredencoding()))
    exit(1)

APPNAME = "intelmq-mailgen"
DESCRIPTION = """
"""

EPILOG = """
Searches for all unprocessed notifications and sends them.
"""

USAGE = """
    intelmq-mailgen
    intelmq-mailgen --all
"""


def read_configuration():
    """Read configuration from user and system settings.
    The return value is a dictionary containing the merged settings read
    from the configuration files.
    """
    # Construct a single configuration dictionary with the contents of
    # the different conf files
    home = os.path.expanduser("~")  # needed for OSX
    user_conf_file = os.path.expanduser(home +
                                        '/.intelmq/intelmq-mailgen.conf')
    sys_conf_file = os.path.expanduser('/etc/intelmq/intelmq-mailgen.conf')
    if os.path.isfile(user_conf_file):
        with open(user_conf_file) \
             as conf_handle:
            user_config = json.load(conf_handle)
    else:
        user_config = dict()
    if os.path.isfile(sys_conf_file):
        with open(sys_conf_file) as conf_handle:
            system_config = json.load(conf_handle)
    else:
        system_config = dict()

    combined = system_config.copy()
    for key, value in user_config.items():
        if isinstance(combined.get(key), dict):
            combined[key].update(value)
        else:
            combined[key] = value

    if not combined:
        raise OSError("No configuration found.")

    return combined


def open_db_connection(config):
    params = config['database']['event']
    return psycopg2.connect(database=params['name'],
                            user=params['username'],
                            password=params['password'],
                            host=params['host'],
                            port=params['port'],
                            # sslmode=params['sslmode'],
                            connection_factory=RealDictConnection)


def full_template_filename(template_dir, template_name):
    """Return the full absolute file name of a template.

    The template_name parameter is interpreted relative to template_dir
    and must refer to a file under that directory. If the resulting file
    name would name a file outside of template_dir, a ValueError
    exception is raised. This check is done to guard against malicious
    template names.
    """
    # make sure absbase ends with "/" so that the check whether the
    # resulting template file name is located under template_dir
    # actually works. os.path.abspath will remove any trailing slashes
    # from its parameter so we can simply append a single one.
    absbase = os.path.abspath(template_dir) + os.path.sep
    absfilename = os.path.abspath(os.path.join(template_dir, template_name))
    if not absfilename.startswith(absbase):
        raise ValueError("Invalid template name %r! Full template filename"
                         " would be outside of the template base directory %r."
                         % (template_name, template_dir))
    return absfilename


def read_template(template_dir, template_name):
    """Read the email template indicated by template_dir and template_name.
    The name of the template file is determined with
    full_template_filename. The first line of the file is assumed to be
    the subject line of the email. The rest of the lines are the email
    body. Leading and trailing white space is removed from the body and
    a newline added at the end. This allows e.g. an empty line in the
    template between the subject line and the body.
    """
    with open(full_template_filename(template_dir, template_name)) as infile:
        subject = None
        while not subject:
            subject = infile.readline().strip()
        body = infile.read().strip() + "\n"
        return subject, body

# characters allowed in identifiers in escape_sql_identifier. There are
# just the characters that are used in IntelMQ for identifiers in the
# events table.
sql_identifier_charset = set(string.ascii_letters + string.digits + "_.")


def escape_sql_identifier(ident):
    if set(ident) - sql_identifier_charset:
        raise ValueError("Event column identifier %r contains invalid"
                         " characters (%r)"
                         % (ident, set(ident) - sql_identifier_charset))
    return '"' + ident + '"'


def load_events(cur, columns, event_ids):
    if columns is not None:
        sql_columns = ", ".join(escape_sql_identifier(col) for col in columns)
    else:
        sql_columns = "*"
    cur.execute("SELECT {} FROM events WHERE id = ANY (%s)".format(
                sql_columns), (event_ids,))

    return cur.fetchall()


def create_malware_xarf_report(e, notification, config):

    logger.debug("xarf: creating malware report for event {}".format(e))
    logger.warn("xarf, malware: Using experimental mapping.")

    params = {
        'schema_cache': '/tmp/',
        'schema_url': 'http://www.x-arf.org/schema/' +
                       'abuse_malware-attack_0.1.4.json',
        'reported_from': config["sender"],
        'report_id': "TODO intelmq ID",  # TODO
        'category': 'abuse',
        'report_type': 'malware-attack',
        'source': e['source.ip'],
        'source_type': 'ip-address',
        'attachment': None,
        }

    if 'time.source' in e and e['time.source']:
        params['date'] = e['time.source'].isoformat(sep=' ')
    else:
        params['date'] = "2016"  # this is just a placeholder TODO

    if 'source.url' in e:
        params['download_link'] = e['source.url']

    # have to set 'attachment' e.g. 'text/plain', if 'evidence' is supplied

    report = Xarf(
        **params
        #schema_cache='/tmp/',
        #schema_url='http://www.x-arf.org/schema/' +
        #           'abuse_malware-attack_0.1.4.json',
        # list of potential parameters (with some examples) for this schema:

        #reported_from=
        #report_id=
        #category='abuse',
        #report_type='malware-attack',
        #destination_system = "enum":["real-world","honeypot","spamtrap",
        #                             "honeyd","nepenthes"], optional
        #date='Jan  1 2014 02:13:35 +0100',
        #date=
        #source='83.169.54.26',
        #source=e['source.ip'],
        #source_type='ip-address', "enum":["ipv4","ipv6","ip-address"]
        #download_link= , optional
        #download_port= , optional
        #malware-md5= , optional
        #antivirus-result= , optional
        #antivirus-vendor= requires":"Antivirus-Result"
        #feedback-link=, optional
        #attachment=  "enum":["none","text/plain", "message/rfc822"]
        #attachement=
        #version= , number, optional
        #occurrences= , integer, optional
        #tlp= "enum":["white","green","amber","red"],optional

        #evidence= , optional would become the additional attachment
        )

    return report


def mail_format_malware_as_xarf(cur, notification, config):
    emails = []

    events = load_events(cur, None, notification["event_ids"])
    for event in events:
        report = create_malware_xarf_report(event, notification, config)

        subject, text = read_template(config["template_dir"],
                                      notification["template"])

        xarfmail = XarfMail(
            report,
            mail_from=config["sender"],
            mail_to=notification["email"],
            subject=subject,
            greeting=text
            )

        emails.append(xarfmail._email)
        # TODO fix pyxarf to be a real email obj

    return emails


def create_mail(sender, recipient, subject, body, attachments):
    msg = MIMEMultipart()
    msg.add_header("From", sender)
    msg.add_header("To", recipient)
    msg.add_header("Subject", subject)
    msg.attach(MIMEText(body))

    for filename, contents, maintype, subtype in attachments:
        part = MIMEBase(maintype, subtype, filename=filename)
        part.set_payload(contents)
        msg.attach(part)

    return msg


malware_columns = [
    "source.asn", "source.ip", "time.source",
    "malware.name", "source.port", "destination.ip",
    "destination.port", "protocol.transport",
    "destination.fqdn",
    ]

all_columns = [
    "classification.identifier",
    "classification.taxonomy", "classification.type", "comment",
    "destination.abuse_contact", "destination.account",
    "destination.allocated", "destination.as_name", "destination.asn",
    "destination.fqdn", "destination.geolocation.cc",
    "destination.geolocation.city", "destination.geolocation.country",
    "destination.geolocation.latitude",
    "destination.geolocation.longitude",
    "destination.geolocation.region", "destination.geolocation.state",
    "destination.ip", "destination.local_hostname",
    "destination.local_ip", "destination.network", "destination.port",
    "destination.registry", "destination.reverse_dns",
    "destination.tor_node", "destination.url",
    "event_description.target", "event_description.text",
    "event_description.url", "event_hash", "malware.hash",
    "malware.hash.md5", "malware.hash.sha1", "malware.name",
    "malware.version", "misp_uuid", "protocol.application",
    "protocol.transport", "rtir_id", "screenshot_url",
    "source.abuse_contact", "source.account", "source.allocated",
    "source.as_name", "source.asn", "source.fqdn",
    "source.geolocation.cc", "source.geolocation.city",
    "source.geolocation.country", "source.geolocation.cymru_cc",
    "source.geolocation.geoip_cc", "source.geolocation.latitude",
    "source.geolocation.longitude", "source.geolocation.region",
    "source.geolocation.state", "source.ip", "source.local_hostname",
    "source.local_ip", "source.network", "source.port",
    "source.registry", "source.reverse_dns", "source.tor_node",
    "source.url", "status", "time.source",
    ]


def format_as_csv(columns, events, header=False):
    contents = io.StringIO()

    writer = csv.DictWriter(contents, columns, delimiter="|")

    if header:
        writer.writeheader()

    for event in events:
        writer.writerow(event)

    return ("events.csv", contents.getvalue(), "text", "csv")


def mail_format_as_csv(columns, cur, notification, config):
    """Creates one email with csv attachment for given columns.

    :returns: list of email objects
    :rtype: list
    """
    attachments = []

    event_attachment = format_as_csv(columns,
        load_events(cur, columns, notification["event_ids"]), True)

    if event_attachment is not None:
        attachments.append(event_attachment)

    subject, body = read_template(config["template_dir"],
                                  notification["template"])

    mail = create_mail(sender=config["sender"],
                       recipient=notification["email"],
                       subject=subject, body=body,
                       attachments=attachments)
    return [mail]


def mail_format_malware_as_csv(cur, notification, config):
    """Creates one email with csv attachment for malware.

    :returns: list of email objects
    :rtype: list
    """
    return mail_format_as_csv(malware_columns, cur, notification, config)


def mail_format_GENERIC_as_csv(cur, notification, config):
    """Creates one email with csv attachment for malware.

    :returns: list of email objects
    :rtype: list
    """
    return mail_format_as_csv(all_columns, cur, notification, config)


known_formatters = {
    ("csv", "malware"):  mail_format_malware_as_csv,
    ("csv", "GENERIC"):  mail_format_GENERIC_as_csv,
    ("xarf", "malware"): mail_format_malware_as_xarf,
    }


def create_mails(cur, notification, config):
    """Create one or several email objects for a notification.

    Depending on the classification_type and format
    does the formatting and returns one or several email objects.

    :param config: script configuration
    :param notification: the notification to create mails for
    :param cur: database cursor to use when loading event information

    :returns: list of email objects with len >=1
    :rtype: list

    """

    emails = []
    formatter = known_formatters.get((notification["format"],
                                       notification["classification_type"]))
    if formatter is None:
        # Try Fallback on "GENERIC" type, that is use a standard set
        # of fields to export.
        formatter = known_formatters.get((notification["format"],
                                           "GENERIC"))

    if formatter is not None:
        emails = formatter(cur, notification, config)
    else:
        msg = ("Cannot generate emails for combination (%r, %r)" %
               (notification["format"], notification["classification_type"]))
        print(msg, file=sys.stderr)
        raise NotImplementedError(msg)

    return emails


def mark_as_sent(cur, notification):
    cur.execute("""WITH ticket AS (SELECT nextval('intelmq_ticket_seq'))
                 UPDATE notifications
                    SET sent_at = now(),
                        intelmq_ticket = (SELECT * FROM ticket)
                  WHERE id = ANY (%s);""",
                (notification["notification_ids"],))


def send_notifications(config, notifications, cur):
    """
    Create and send notification mails for all items in notifications.

    All notifications that were successfully sent are marked as sent in
    the database. This function tries to make sure that this information
    can be committed as part of the transaction in progress even if
    errors occur during SQL statements executed by this function. The
    caller should also catch exceptions thrown by this method and always
    commit the transaction.

    :param config script configuration
    :param notifications a list of notifications
    :param cur database cursor to use when loading event information

    :returns: number of send mails
    :rtype: int
    """
    sent_mails = 0
    with smtplib.SMTP(host=config["smtp"]["host"],
                      port=config["smtp"]["port"]) as smtp:
        for notification in notifications:
            cur.execute("SAVEPOINT sendmail;")
            try:
                emails = create_mails(cur, notification, config)

                if len(emails) < 1:
                    # TODO maybe use a user defined exception here?
                    raise RuntimeError("No emails for sending were generated!")
                for email in emails:
                    smtp.send_message(email)
                    sent_mails += 1

                mark_as_sent(cur, notification)
            except:
                cur.execute("ROLLBACK TO SAVEPOINT sendmail;")
                raise
            finally:
                cur.execute("RELEASE SAVEPOINT sendmail;")
    return sent_mails


def get_pending_notifications(cur):
    """Retrieve all pending notifications from the database.
    Notifications are pending if they haven't been sent yet.
    Notifications are grouped by recipient, template and format so that
    the information about the events for which the notifications are
    sent can be aggregated.
    """
    cur.execute("""\
        SELECT n.email as email, n.template as template, n.format as format,
               n.classification_type as classification_type,
               array_agg(n.events_id) as event_ids,
               array_agg(n.id) as notification_ids
          FROM (SELECT * FROM notifications
                WHERE intelmq_ticket IS NULL
                FOR UPDATE NOWAIT) n
      GROUP BY n.email, n.template, n.format, n.classification_type
        HAVING coalesce((SELECT max(sent_at) FROM notifications n2
                         WHERE n2.email = n.email AND n2.template = n.template
                         AND n2.format = n.format)
                        + max(n.notification_interval)
                        < CURRENT_TIMESTAMP,
                        TRUE);""")
    return cur.fetchall()


def generate_notifications_interactively(config, cur, notifications):
    batch_size = 10

    pending = notifications[:]
    while pending:
        batch, pending = pending[:batch_size], pending[batch_size:]
        print('Current batch (%d of %d total):'
              % (len(batch), len(batch) + len(pending)))
        for i in batch:
            print('    * {0} {1} ({2}, {3}): {4} events'.format(
                  i["email"],
                  i["template"],
                  i["format"],
                  i["classification_type"],
                  len(i["event_ids"]))
                  )
        valid_answers = ("c", "s", "a", "q")
        while True:
            answer = input("Options: [c]ontinue, "
                           "[s]end this batch, "
                           "send [a]ll, "
                           "[q]uit? ").strip()
            if answer not in valid_answers:
                print("Please enter one of the characters %s"
                      % ", ".join(valid_answers))
            else:
                break
        if answer == "c":
            print("Skipping this batch.")
            pass
        elif answer == "q":
            print("Exiting without sending any further mails.")
            pending = []
        else:
            to_send = batch
            if answer == "a":
                to_send.extend(pending)
                pending = []

            print("Sending mails for %d entries... " % (len(to_send),))
            sent_mails = send_notifications(config, to_send, cur)
            print("%d mails sent. " % (sent_mails,))


def generate_notifications(args, config):
    cur = None
    conn = open_db_connection(config)
    try:
        cur = conn.cursor()
        notifications = get_pending_notifications(cur)
        if not notifications:
            print("No pending notifications to be sent")
            return

        if args.all:
            send_notifications(config, notifications, cur)
        else:
            generate_notifications_interactively(config, cur, notifications)

    finally:
        if cur is not None:
            cur.close()
        # the only change to the database is marking the sent mails as
        # actually sent. We always want to commit that information even
        # when errors occur, so we're calling commit in the finally
        # block.
        conn.commit()
        conn.close()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog=APPNAME,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        usage=USAGE,
        description=DESCRIPTION,
        epilog=EPILOG,
        )
    parser.add_argument('-a', '--all', action='store_true',
                        help='Process all events (batch mode)')
    args = parser.parse_args()

    config = read_configuration()

    generate_notifications(args, config)
