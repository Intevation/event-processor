#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Command line tool to send notfications for intelmq events.
"""

import smtplib
import argparse
import json
import locale
import os
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication

import psycopg2
import psycopg2.extras
from termstyle import red


if locale.getpreferredencoding() != 'UTF-8':
    print(red('The preferred encoding of your locale setting is not UTF-8 but'
              '{}. Exiting.'.format(locale.getpreferredencoding())))
    exit(1)


EMAIL_FROM = 'noreply@example.com'

APPNAME = "intelmqcli"
DESCRIPTION = """
"""

EPILOG = """
Searches for all unprocessed notifications and sends them.
"""

USAGE = """
    intelmqcli
    intelmqcli --all
"""


def read_configuration():
    """Read configuration from user and system settings.
    The return value is a dictionary containing the merged settings read
    from the configuration files.
    """
    # Construct a single configuration dictionary with the contents of
    # the different conf files
    home = os.path.expanduser("~")  # needed for OSX
    with open(os.path.expanduser(home + '/.intelmq/intelmqcli.conf')) \
         as conf_handle:
        user_config = json.load(conf_handle)
    with open('/etc/intelmq/intelmqcli.conf') as conf_handle:
        system_config = json.load(conf_handle)

    combined = system_config.copy()
    for key, value in user_config.items():
        if isinstance(combined.get(key), dict):
            combined[key].update(value)
        else:
            combined[key] = value

    return combined


def open_db_connection(config):
    conn = psycopg2.connect(database=config['database']['event']['name'],
                            user=config['database']['event']['username'],
                            password=config['database']['event']['password'],
                            host=config['database']['event']['host'],
                            port=config['database']['event']['port'],
                            # sslmode=config['database']['event']['sslmode'],
                            )
    cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
    conn.autocommit = True
    return cur


def create_mail(sender, recipient, subject, body):
    msg = MIMEMultipart()
    msg.add_header("From", sender)
    msg.add_header("To", recipient)
    msg.add_header("Subject", subject)
    msg.attach(MIMEText(body))
    return msg


def send_notifications(config, notifications):
    """Create and send notification mails for all items in notifications.
    :param config script configuration
    :param notifications a list of notifications
    """
    with smtplib.SMTP(host=config["smtp"]["host"],
                      port=config["smtp"]["port"]) as smtp:
        for notification in notifications:
            smtp.send_message(create_mail(sender=EMAIL_FROM,
                                          recipient='contact email',
                                          subject='email subject',
                                          body='email body'))


def get_pending_notifications(cur):
    """Retrieve all pending notifications from the database.
    Notifications are pending if they haven't been sent yet.
    Notifications are grouped by recipient, template and format so that
    the information about the events for which the notifications are
    sent can be aggregated.
    """
    cur.execute("""\
        SELECT n.email as email, n.template as template, n.format as format,
               array_agg(n.events_id) as event_ids,
               array_agg(n.id) as notification_ids
          FROM (SELECT * FROM notifications
                WHERE intelmq_ticket IS NULL
                FOR UPDATE NOWAIT) n
      GROUP BY n.email, n.template, n.format
        HAVING coalesce((SELECT max(sent_at) FROM notifications n2
                         WHERE n2.email = n.email AND n2.template = n.template
                         AND n2.format = n.format)
                        + max(n.notification_interval)
                        < CURRENT_TIMESTAMP,
                        TRUE);""")
    return cur.fetchall()


def generate_notifications(args, config):
    cur = open_db_connection(config)
    event_list = get_pending_notifications(cur)
    while event_list:
        to_process = event_list[:10]
        if not args.all:
            print('Current batch:')
            for i in to_process:
                print('    * {0} {1} {2}: {3} events'.format(
                    i["email"], i["template"], i["format"],
                    len(i["event_ids"])))

        if args.all:
            answer = 'a'
        else:
            answer = input('Options: [c]ontinue, [s]end this batch, send [a]ll,'
                           ' [q]uit? ')

        if answer == 'c':
            print('Continue')
        elif answer == 's':
            print('Sending this batch')
            event_list[:10] = []
            send_notifications(config, to_process)
        elif answer == 'a':
            print('Sending all')
            to_process = event_list[:]
            event_list = []
            send_notifications(config, to_process)
        else:
            print('Exiting')
            break


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog=APPNAME,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        usage=USAGE,
        description=DESCRIPTION,
        epilog=EPILOG,
    )
    parser.add_argument('-a', '--all', action='store_true',
                        help='Process all events (batch mode)')
    args = parser.parse_args()

    config = read_configuration()

    generate_notifications(args, config)
