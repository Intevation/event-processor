#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Command line tool to send notfications for intelmq events.
"""

import smtplib
import argparse
import json
import locale
import os
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication

import psycopg2
import psycopg2.extras
from termstyle import red


if locale.getpreferredencoding() != 'UTF-8':
    print(red('The preferred encoding of your locale setting is not UTF-8 but'
              '{}. Exiting.'.format(locale.getpreferredencoding())))
    exit(1)


EMAIL_FROM = 'noreply@example.com'

APPNAME = "intelmqcli"
DESCRIPTION = """
"""

EPILOG = """
Searches for all unprocessed notifications and sends them.
"""

USAGE = """
    intelmqcli
    intelmqcli --all
"""


def read_configuration():
    """Read configuration from user and system settings.
    The return value is a dictionary containing the merged settings read
    from the configuration files.
    """
    # Construct a single configuration dictionary with the contents of
    # the different conf files
    home = os.path.expanduser("~")  # needed for OSX
    with open(os.path.expanduser(home + '/.intelmq/intelmqcli.conf')) \
         as conf_handle:
        user_config = json.load(conf_handle)
    with open('/etc/intelmq/intelmqcli.conf') as conf_handle:
        system_config = json.load(conf_handle)

    combined = system_config.copy()
    for key, value in user_config.items():
        if isinstance(combined.get(key), dict):
            combined[key].update(value)
        else:
            combined[key] = value

    return combined


def open_db_connection(config):
    conn = psycopg2.connect(database=config['database']['event']['name'],
                            user=config['database']['event']['username'],
                            password=config['database']['event']['password'],
                            host=config['database']['event']['host'],
                            port=config['database']['event']['port'],
                            # sslmode=config['database']['event']['sslmode'],
                            )
    cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
    conn.autocommit = True
    return cur

QUERY_GET_EVENTS = """SELECT * FROM events LIMIT 40"""


def send_email(email_event):
    '''
    Sends processed events to the corresponding contacts

    :param email_event: a dictionary with the processed data from an event
    '''
    msg = MIMEMultipart(
        From=EMAIL_FROM,
        To=email_event['email_to'],
        Subject=email_event['subject']
    )
    msg.attach(MIMEText(email_event['email_body']))

    for f in email_event['files'] or []:
        with open(f, "rb") as fil:
            msg.attach(MIMEApplication(
                fil.read(),
                Content_Disposition=('attachment; filename="%s"'
                                     % os.path.basename(f)),
                Name=basename(f)
            ))

    smtp = smtplib.SMTP(server)
    smtp.sendmail(EMAIL_FROM, email_event['email_to'], msg.as_string())
    smtp.close()


def process_events(event_list):
    '''
    Processes each event

    This helper also generates a dictionary that is used when sending the emails

    :param event_list a list of events as created by get_event_list
    '''
    for event in event_list:
        event_email = {}
        event_email['email_to'] = 'contact email'
        event_email['subject'] = 'email subject'

        # The email body. This is generated by combining the template with the
        # event's data and other sources as needed.
        event_email['email_body'] = 'email body'

        # List of files (see format table) to be sent with the email
        event_email['files'] = []
        send_email(event_email)
    pass


def get_event_list(cur):
    '''
    Retrieves the current event list and groups and sorts them
    '''
    cur.execute(QUERY_GET_EVENTS)
    event_list = [i for i in cur.fetchall()]

    return event_list


def generate_notifications(args, config):
    cur = open_db_connection(config)
    event_list = get_event_list(cur)
    while event_list:
        to_process = event_list[:10]
        if not args.all:
            print('Current batch:')
            for i in to_process:
                print('    * {0}'.format(i.get('event_description.text')))

        if args.all:
            answer = 'a'
        else:
            answer = input('Options: [c]ontinue, [s]end this batch, send [a]ll,'
                           ' [q]uit? ')

        if answer == 'c':
            print('Continue')
        elif answer == 's':
            print('Sending this batch')
            event_list[:10] = []
            process_events(to_process)
        elif answer == 'a':
            print('Sending all')
            to_process = event_list[:]
            event_list = []
            process_events(to_process)
        else:
            print('Exiting')
            break


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog=APPNAME,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        usage=USAGE,
        description=DESCRIPTION,
        epilog=EPILOG,
    )
    parser.add_argument('-a', '--all', action='store_true',
                        help='Process all events (batch mode)')
    args = parser.parse_args()

    config = read_configuration()

    generate_notifications(args, config)
